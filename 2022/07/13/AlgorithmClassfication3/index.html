<!DOCTYPE html>
<html lang="en">
    <head>
    <meta charset="utf-8">

    

    <!-- 渲染优化 -->
    <meta name="renderer" content="webkit">
    <meta name="force-rendering" content="webkit">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="HandheldFriendly" content="True" >
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <!--icon-->

    
    
    
    
    


    <!-- meta -->


<title>AlgorithmClassfication3 | 穿过海的声音</title>





    <!-- OpenGraph -->
 
    <meta name="description" content="树144. 二叉树的前序遍历12345678910111213141516171819202122232425class Solution &amp;#123;    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &amp;#123;        Deque&lt;TreeNode&gt; stack &#x3D; new ArrayDeque&amp;l">
<meta property="og:type" content="article">
<meta property="og:title" content="AlgorithmClassfication3">
<meta property="og:url" content="http://example.com/2022/07/13/AlgorithmClassfication3/index.html">
<meta property="og:site_name" content="穿过海的声音">
<meta property="og:description" content="树144. 二叉树的前序遍历12345678910111213141516171819202122232425class Solution &amp;#123;    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &amp;#123;        Deque&lt;TreeNode&gt; stack &#x3D; new ArrayDeque&amp;l">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://s2.loli.net/2022/08/08/RO7mQAiLajoWdf3.png">
<meta property="article:published_time" content="2022-07-13T00:34:00.000Z">
<meta property="article:modified_time" content="2022-08-16T15:08:06.367Z">
<meta property="article:author" content="jcwang">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://s2.loli.net/2022/08/08/RO7mQAiLajoWdf3.png">


    
<link rel="stylesheet" href="/css/style/main.css">
 

    
    
        <link rel="stylesheet" id="hl-default-theme" href="/css/highlight/default.css" media="none" onload="this.media='all'">
        
    

    
    

    

     

    <!-- custom head -->

<meta name="generator" content="Hexo 6.0.0"></head>

    <body>
        <div id="app">
            <header class="header">
    <div class="header__left">
        <a href="/" class="button">
            <span class="logo__text">欢迎</span>
        </a>
    </div>
    <div class="header__right">
        
            <div class="navbar__menus">
                
                    <a href="/" class="navbar-menu button">首页</a>
                
                    <a href="/tags/" class="navbar-menu button">标签</a>
                
                    <a href="/archives/" class="navbar-menu button">归档</a>
                
                    <a href="/friends/" class="navbar-menu button">友链</a>
                
                    <a href="/page/" class="navbar-menu button">Page</a>
                
            </div>
        
        
        

        
        

        
            <a class="dropdown-icon button" id="btn-dropdown" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width='24' height='24' fill="none" stroke="currentColor" stroke-width="0.7" stroke-linecap="round" stroke-linejoin="round"><path fill="currentColor" d="M3.314,4.8h13.372c0.41,0,0.743-0.333,0.743-0.743c0-0.41-0.333-0.743-0.743-0.743H3.314c-0.41,0-0.743,0.333-0.743,0.743C2.571,4.467,2.904,4.8,3.314,4.8z M16.686,15.2H3.314c-0.41,0-0.743,0.333-0.743,0.743s0.333,0.743,0.743,0.743h13.372c0.41,0,0.743-0.333,0.743-0.743S17.096,15.2,16.686,15.2z M16.686,9.257H3.314c-0.41,0-0.743,0.333-0.743,0.743s0.333,0.743,0.743,0.743h13.372c0.41,0,0.743-0.333,0.743-0.743S17.096,9.257,16.686,9.257z"></path></svg></a>
            <div class="dropdown-menus" id="dropdown-menus">
                
                    <a href="/" class="dropdown-menu button">首页</a>
                
                    <a href="/tags/" class="dropdown-menu button">标签</a>
                
                    <a href="/archives/" class="dropdown-menu button">归档</a>
                
                    <a href="/friends/" class="dropdown-menu button">友链</a>
                
                    <a href="/page/" class="dropdown-menu button">Page</a>
                
            </div>
        
    </div>
</header>


            <main class="main">
    

<div class="post-title">
    <h1 class="post-title__text">
        AlgorithmClassfication3
    </h1>
    <div class="post-title__meta">
        <a href="/archives/2022/07/" class="post-meta__date button">2022-07-13</a>
        
 
        
    
    


 

 
    </div>
</div>


    <aside class="post-side">
        <div class="post-side__toc">
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91"><span class="toc-number">1.</span> <span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.1.</span> <span class="toc-text">144. 二叉树的前序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.2.</span> <span class="toc-text">94. 二叉树的中序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.3.</span> <span class="toc-text">145. 二叉树的后序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#107-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-II"><span class="toc-number">1.4.</span> <span class="toc-text">107. 二叉树的层序遍历 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#230-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-number">1.5.</span> <span class="toc-text">230. 二叉搜索树中第K小的元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5-II"><span class="toc-number">1.6.</span> <span class="toc-text">240. 搜索二维矩阵 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#297-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">1.7.</span> <span class="toc-text">297. 二叉树的序列化与反序列化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-III"><span class="toc-number">1.8.</span> <span class="toc-text">437. 路径总和 III</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%EF%BC%9A%E4%BB%8E%E8%AF%A5%E8%8A%82%E7%82%B9%E5%BE%80%E4%B8%8B%E7%9A%84%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-number">1.8.1.</span> <span class="toc-text">注意：从该节点往下的路径和</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number">1.9.</span> <span class="toc-text">450. 删除二叉搜索树中的节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#563-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9D%A1%E5%BA%A6"><span class="toc-number">1.10.</span> <span class="toc-text">563. 二叉树的坡度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%EF%BC%9A%E5%89%8D%E7%BC%80%E5%92%8C%EF%BC%8C%E9%AB%98%E5%BA%A6%EF%BC%9B%E4%BB%8E%E5%8F%B6%E5%AD%90%E5%88%B0%E8%AF%A5%E8%8A%82%E7%82%B9%E5%92%8C"><span class="toc-number">1.10.1.</span> <span class="toc-text">注意：前缀和，高度；从叶子到该节点和</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-number">1.11.</span> <span class="toc-text">124. 二叉树中的最大路径和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C-1"><span class="toc-number">1.12.</span> <span class="toc-text">124. 二叉树中的最大路径和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#606-%E6%A0%B9%E6%8D%AE%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.13.</span> <span class="toc-text">606. 根据二叉树创建字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#653-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-IV-%E8%BE%93%E5%85%A5-BST"><span class="toc-number">1.14.</span> <span class="toc-text">653. 两数之和 IV - 输入 BST</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#783-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%8A%82%E7%82%B9%E6%9C%80%E5%B0%8F%E8%B7%9D%E7%A6%BB"><span class="toc-number">1.15.</span> <span class="toc-text">783. 二叉搜索树节点最小距离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#938-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E8%8C%83%E5%9B%B4%E5%92%8C"><span class="toc-number">1.16.</span> <span class="toc-text">938. 二叉搜索树的范围和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#965-%E5%8D%95%E5%80%BC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.17.</span> <span class="toc-text">965. 单值二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#993-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%A0%82%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9"><span class="toc-number">1.18.</span> <span class="toc-text">993. 二叉树的堂兄弟节点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9C%B0%E5%93%88%E5%B8%8C"><span class="toc-number">2.</span> <span class="toc-text">原地哈希</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#442-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">2.1.</span> <span class="toc-text">442. 数组中重复的数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E3%80%81%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E3%80%81treeset%E3%80%81treemap"><span class="toc-number">3.</span> <span class="toc-text">优先队列、单调队列、treeset、treemap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1675-%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E5%81%8F%E7%A7%BB%E9%87%8F"><span class="toc-number">3.1.</span> <span class="toc-text">1675. 数组的最小偏移量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1438-%E7%BB%9D%E5%AF%B9%E5%B7%AE%E4%B8%8D%E8%B6%85%E8%BF%87%E9%99%90%E5%88%B6%E7%9A%84%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">3.2.</span> <span class="toc-text">1438. 绝对差不超过限制的最长连续子数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88%E7%9A%84%E7%9B%B8%E4%BA%92%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.3.</span> <span class="toc-text">队列和栈的相互实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="toc-number">3.3.1.</span> <span class="toc-text">两个栈实现队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88"><span class="toc-number">3.3.2.</span> <span class="toc-text">两个队列实现栈</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#641-%E8%AE%BE%E8%AE%A1%E5%BE%AA%E7%8E%AF%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97"><span class="toc-number">3.4.</span> <span class="toc-text">641. 设计循环双端队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">4.</span> <span class="toc-text">并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%981"><span class="toc-number">4.1.</span> <span class="toc-text">题1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%82%A1%E7%A5%A8%E6%8E%A8%E8%8D%90"><span class="toc-number">4.2.</span> <span class="toc-text">股票推荐</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE"><span class="toc-number">4.2.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5"><span class="toc-number">4.2.2.</span> <span class="toc-text">输入</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1631-%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84"><span class="toc-number">4.3.</span> <span class="toc-text">1631. 最小体力消耗路径</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86-Kruskal"><span class="toc-number">4.3.1.</span> <span class="toc-text">并查集 + Kruskal</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#947-%E7%A7%BB%E9%99%A4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%90%8C%E8%A1%8C%E6%88%96%E5%90%8C%E5%88%97%E7%9F%B3%E5%A4%B4"><span class="toc-number">4.4.</span> <span class="toc-text">947. 移除最多的同行或同列石头</span></a></li></ol></li></ol>
        </div>
    </aside>
    <a class="btn-toc button" id="btn-toc" tabindex="0">
        <svg viewBox="0 0 1024 1024" width="32" height="32" xmlns="http://www.w3.org/2000/svg">
            <path d="M128 256h64V192H128zM320 256h576V192H320zM128 544h64v-64H128zM320 544h576v-64H320zM128 832h64v-64H128zM320 832h576v-64H320z" fill="currentColor"></path>
        </svg>
    </a>
    <div class="toc-menus" id="toc-menus">
        <div class="toc-title">Article Directory</div>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91"><span class="toc-number">1.</span> <span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.1.</span> <span class="toc-text">144. 二叉树的前序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.2.</span> <span class="toc-text">94. 二叉树的中序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.3.</span> <span class="toc-text">145. 二叉树的后序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#107-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-II"><span class="toc-number">1.4.</span> <span class="toc-text">107. 二叉树的层序遍历 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#230-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-number">1.5.</span> <span class="toc-text">230. 二叉搜索树中第K小的元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5-II"><span class="toc-number">1.6.</span> <span class="toc-text">240. 搜索二维矩阵 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#297-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">1.7.</span> <span class="toc-text">297. 二叉树的序列化与反序列化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-III"><span class="toc-number">1.8.</span> <span class="toc-text">437. 路径总和 III</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%EF%BC%9A%E4%BB%8E%E8%AF%A5%E8%8A%82%E7%82%B9%E5%BE%80%E4%B8%8B%E7%9A%84%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-number">1.8.1.</span> <span class="toc-text">注意：从该节点往下的路径和</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number">1.9.</span> <span class="toc-text">450. 删除二叉搜索树中的节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#563-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9D%A1%E5%BA%A6"><span class="toc-number">1.10.</span> <span class="toc-text">563. 二叉树的坡度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%EF%BC%9A%E5%89%8D%E7%BC%80%E5%92%8C%EF%BC%8C%E9%AB%98%E5%BA%A6%EF%BC%9B%E4%BB%8E%E5%8F%B6%E5%AD%90%E5%88%B0%E8%AF%A5%E8%8A%82%E7%82%B9%E5%92%8C"><span class="toc-number">1.10.1.</span> <span class="toc-text">注意：前缀和，高度；从叶子到该节点和</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-number">1.11.</span> <span class="toc-text">124. 二叉树中的最大路径和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C-1"><span class="toc-number">1.12.</span> <span class="toc-text">124. 二叉树中的最大路径和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#606-%E6%A0%B9%E6%8D%AE%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.13.</span> <span class="toc-text">606. 根据二叉树创建字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#653-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-IV-%E8%BE%93%E5%85%A5-BST"><span class="toc-number">1.14.</span> <span class="toc-text">653. 两数之和 IV - 输入 BST</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#783-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%8A%82%E7%82%B9%E6%9C%80%E5%B0%8F%E8%B7%9D%E7%A6%BB"><span class="toc-number">1.15.</span> <span class="toc-text">783. 二叉搜索树节点最小距离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#938-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E8%8C%83%E5%9B%B4%E5%92%8C"><span class="toc-number">1.16.</span> <span class="toc-text">938. 二叉搜索树的范围和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#965-%E5%8D%95%E5%80%BC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.17.</span> <span class="toc-text">965. 单值二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#993-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%A0%82%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9"><span class="toc-number">1.18.</span> <span class="toc-text">993. 二叉树的堂兄弟节点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9C%B0%E5%93%88%E5%B8%8C"><span class="toc-number">2.</span> <span class="toc-text">原地哈希</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#442-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">2.1.</span> <span class="toc-text">442. 数组中重复的数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E3%80%81%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E3%80%81treeset%E3%80%81treemap"><span class="toc-number">3.</span> <span class="toc-text">优先队列、单调队列、treeset、treemap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1675-%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E5%81%8F%E7%A7%BB%E9%87%8F"><span class="toc-number">3.1.</span> <span class="toc-text">1675. 数组的最小偏移量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1438-%E7%BB%9D%E5%AF%B9%E5%B7%AE%E4%B8%8D%E8%B6%85%E8%BF%87%E9%99%90%E5%88%B6%E7%9A%84%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">3.2.</span> <span class="toc-text">1438. 绝对差不超过限制的最长连续子数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88%E7%9A%84%E7%9B%B8%E4%BA%92%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.3.</span> <span class="toc-text">队列和栈的相互实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="toc-number">3.3.1.</span> <span class="toc-text">两个栈实现队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88"><span class="toc-number">3.3.2.</span> <span class="toc-text">两个队列实现栈</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#641-%E8%AE%BE%E8%AE%A1%E5%BE%AA%E7%8E%AF%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97"><span class="toc-number">3.4.</span> <span class="toc-text">641. 设计循环双端队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">4.</span> <span class="toc-text">并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%981"><span class="toc-number">4.1.</span> <span class="toc-text">题1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%82%A1%E7%A5%A8%E6%8E%A8%E8%8D%90"><span class="toc-number">4.2.</span> <span class="toc-text">股票推荐</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE"><span class="toc-number">4.2.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5"><span class="toc-number">4.2.2.</span> <span class="toc-text">输入</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1631-%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84"><span class="toc-number">4.3.</span> <span class="toc-text">1631. 最小体力消耗路径</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86-Kruskal"><span class="toc-number">4.3.1.</span> <span class="toc-text">并查集 + Kruskal</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#947-%E7%A7%BB%E9%99%A4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%90%8C%E8%A1%8C%E6%88%96%E5%90%8C%E5%88%97%E7%9F%B3%E5%A4%B4"><span class="toc-number">4.4.</span> <span class="toc-text">947. 移除最多的同行或同列石头</span></a></li></ol></li></ol>
    </div>


<article class="post post__with-toc content-card">
    <div class="post__header"></div>
    <div class="post__content">
        <h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack.offerLast(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">tempNode</span> <span class="operator">=</span> stack.pollLast();</span><br><span class="line">            ans.add(tempNode.val);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tempNode.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.offerLast(tempNode.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tempNode.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.offerLast(tempNode.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.offerLast(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            root = stack.pollLast();</span><br><span class="line">            ans.add(root.val);</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方案一，与中序遍历类似</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 与中序遍历类似</span></span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 表示上一个被访问到的，因为左右中，所以中间的右边遍历完成才能访问中间</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() || root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.offerLast(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            root = stack.pollLast();</span><br><span class="line">            <span class="comment">// 因为左右中，所以有节点不存在，或者有节点是上一个已经访问过了，那么可以访问这个中间节点</span></span><br><span class="line">            <span class="keyword">if</span> (root.right == <span class="literal">null</span> || root.right == prev) &#123;</span><br><span class="line">                ans.add(root.val);</span><br><span class="line">                prev = root;</span><br><span class="line">                root = <span class="literal">null</span>; <span class="comment">// 注意需要root=null，来取出stack中下面一个</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.offerLast(root);</span><br><span class="line">                root = root.right; <span class="comment">// 右节点存在，并且没有访问过</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二，与前序遍历类似</span></span><br><span class="line"><span class="comment">// 前序遍历的过程 是 中左右。</span></span><br><span class="line"><span class="comment">// 将其转化成 中右左（就是类似前序遍历，不过这里是遍历中右左，然后反过来打印即可）。也就是压栈的过程中优先压入左子树，在压入右子树。需要两个栈</span></span><br><span class="line"><span class="comment">// 然后将这个结果返回来，这里是利用栈的先进后出倒序打印。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">postOrderIteration</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    stack1.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack1.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">tempNode</span> <span class="operator">=</span> stack1.pop();</span><br><span class="line">        stack2.push(tempNode);</span><br><span class="line">        <span class="keyword">if</span> (tempNode.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack1.push(tempNode.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tempNode.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack1.push(tempNode.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!stack2.isEmpty()) &#123;</span><br><span class="line">        System.out.print(stack2.pop().value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="107-二叉树的层序遍历-II"><a href="#107-二叉树的层序遍历-II" class="headerlink" title="107. 二叉树的层序遍历 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">107. 二叉树的层序遍历 II</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrderBottom</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 层序遍历，结果使用头插</span></span><br><span class="line">        Deque&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        queue.offerLast(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">tempNode</span> <span class="operator">=</span> queue.pollFirst();</span><br><span class="line">                list.add(tempNode.val);</span><br><span class="line">                <span class="keyword">if</span>(tempNode.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offerLast(tempNode.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (tempNode.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offerLast(tempNode.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ans.add(<span class="number">0</span>, list); <span class="comment">// 头插</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="230-二叉搜索树中第K小的元素"><a href="#230-二叉搜索树中第K小的元素" class="headerlink" title="230. 二叉搜索树中第K小的元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第K小的元素</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        searchK(root, k);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">searchK</span><span class="params">(TreeNode node, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line">        searchK(node.left, k);</span><br><span class="line">        <span class="keyword">if</span> (++num == k) &#123;</span><br><span class="line">            ans = node.val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        searchK(node.right, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用栈进行迭代中序遍历，这样就没有递归中序遍历的全局变量了</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意此处没有先加入节点这个操作，而是每次不断的把做节点加入</span></span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        stack.offerLast(root);</span><br><span class="line">        root = root.left;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      root = stack.pollLast();</span><br><span class="line">      <span class="keyword">if</span> (--k == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root.val;</span><br><span class="line">      &#125;</span><br><span class="line">      root = root.right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root.val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="240-搜索二维矩阵-II"><a href="#240-搜索二维矩阵-II" class="headerlink" title="240. 搜索二维矩阵 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-a-2d-matrix-ii/">240. 搜索二维矩阵 II</a></h3><h3 id="297-二叉树的序列化与反序列化"><a href="#297-二叉树的序列化与反序列化" class="headerlink" title="297. 二叉树的序列化与反序列化"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/">297. 二叉树的序列化与反序列化</a></h3><h3 id="437-路径总和-III"><a href="#437-路径总和-III" class="headerlink" title="437. 路径总和 III"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-iii/">437. 路径总和 III</a></h3><p><strong>路径</strong> 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
<h4 id="注意：从该节点往下的路径和"><a href="#注意：从该节点往下的路径和" class="headerlink" title="注意：从该节点往下的路径和"></a>注意：从该节点往下的路径和</h4><p>所以此处的参数还是写在里面的，而不是返回值里面</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        dfs1(root, targetSum);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有的节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs1</span><span class="params">(TreeNode node, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs2(node, targetSum, <span class="number">0</span>);</span><br><span class="line">        dfs1(node.left, targetSum);</span><br><span class="line">        dfs1(node.right, targetSum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以该节点为跟节点的所有路径和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs2</span><span class="params">(TreeNode node, <span class="type">int</span> targetSum, <span class="type">int</span> val)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        val += node.val;</span><br><span class="line">        <span class="keyword">if</span> (val == targetSum) &#123;</span><br><span class="line">            ans += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs2(node.left, targetSum, val);</span><br><span class="line">        dfs2(node.right, targetSum, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450. 删除二叉搜索树中的节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a></h3><p>这道题目的做好好好注意一下，</p>
<p>比如拿到a的left指针node，如果给这个指针赋成别的地址，那么之前的a的left指针是没有变的，因为指向的是固定的地址（除非更改a的left值），而不是指针的指针。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="comment">// 注意，是二叉搜索树呀</span></span><br><span class="line">        <span class="comment">// 首先找到，要被删除的节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> root, nodePar = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key &lt; node.val) &#123;</span><br><span class="line">                nodePar = node;</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node.val) &#123;</span><br><span class="line">                nodePar = node;</span><br><span class="line">                node = node.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == node) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 然后分类删除</span></span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            node = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.left == <span class="literal">null</span>) &#123;</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 找出右边节点的最小节点，用它代替到该节点，然后删除</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">succ</span> <span class="operator">=</span> node.right, succPar = node;</span><br><span class="line">            <span class="keyword">while</span> (succ.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                succPar = succ;</span><br><span class="line">                succ = succ.left;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 然后将找到的后记节点succ放到node的位置，下面这个判断是succ就是node.right</span></span><br><span class="line">            <span class="keyword">if</span> (node.right != succ) &#123;</span><br><span class="line">                succPar.left = succ.right;</span><br><span class="line">                succ.left = node.left;</span><br><span class="line">                succ.right = node.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果succ就是node.right，node没有左边节点，直接这样就行</span></span><br><span class="line">                succ.left = node.left;</span><br><span class="line">            &#125;</span><br><span class="line">            node = succ;   </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nodePar == <span class="literal">null</span>) &#123; <span class="comment">// 被删除的是父节点</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodePar.left != <span class="literal">null</span> &amp;&amp; nodePar.left.val == key) &#123;</span><br><span class="line">            nodePar.left = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nodePar.right = node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="563-二叉树的坡度"><a href="#563-二叉树的坡度" class="headerlink" title="563. 二叉树的坡度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-tilt/">563. 二叉树的坡度</a></h3><h4 id="注意：前缀和，高度；从叶子到该节点和"><a href="#注意：前缀和，高度；从叶子到该节点和" class="headerlink" title="注意：前缀和，高度；从叶子到该节点和"></a>注意：前缀和，高度；从叶子到该节点和</h4><p>求前缀和，高度等，是从上往下面求的，所以参数放在函数中即可，（求高度返回值里面也要有）。</p>
<p>但是求从底部叶子到顶部的和，需要将值放在返回值中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTilt</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">sumLeft</span> <span class="operator">=</span> dfs(node.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sumRight</span> <span class="operator">=</span> dfs(node.right);</span><br><span class="line"></span><br><span class="line">        ans += Math.abs(sumRight - sumLeft);</span><br><span class="line">        <span class="keyword">return</span> node.val + sumLeft + sumRight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124. 二叉树中的最大路径和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></h3><p>这个也是从低向上，所以可以放在外面</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPathSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        maxGain(root);</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxGain</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归计算左右子节点的最大贡献值</span></span><br><span class="line">        <span class="comment">// 只有在最大贡献值大于 0 时，才会选取对应子节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftGain</span> <span class="operator">=</span> Math.max(maxGain(node.left), <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightGain</span> <span class="operator">=</span> Math.max(maxGain(node.right), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">priceNewpath</span> <span class="operator">=</span> node.val + leftGain + rightGain;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新答案</span></span><br><span class="line">        maxSum = Math.max(maxSum, priceNewpath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回节点的最大贡献值</span></span><br><span class="line">        <span class="keyword">return</span> node.val + Math.max(leftGain, rightGain);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="124-二叉树中的最大路径和-1"><a href="#124-二叉树中的最大路径和-1" class="headerlink" title="124. 二叉树中的最大路径和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></h3><h3 id="606-根据二叉树创建字符串"><a href="#606-根据二叉树创建字符串" class="headerlink" title="606. 根据二叉树创建字符串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-string-from-binary-tree/">606. 根据二叉树创建字符串</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">tree2str</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">dfs</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span> + node.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> node.val + <span class="string">&quot;(&quot;</span> + dfs(node.left) + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.val + <span class="string">&quot;(&quot;</span> + dfs(node.left) + <span class="string">&quot;)(&quot;</span> + dfs(node.right) + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="653-两数之和-IV-输入-BST"><a href="#653-两数之和-IV-输入-BST" class="headerlink" title="653. 两数之和 IV - 输入 BST"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum-iv-input-is-a-bst/">653. 两数之和 IV - 输入 BST</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">findTarget</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(root, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(TreeNode node, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (set.contains(k - node.val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        set.add(node.val);</span><br><span class="line">        <span class="keyword">return</span> dfs(node.left, k) || dfs(node.right, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="783-二叉搜索树节点最小距离"><a href="#783-二叉搜索树节点最小距离" class="headerlink" title="783. 二叉搜索树节点最小距离"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-distance-between-bst-nodes/">783. 二叉搜索树节点最小距离</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 二叉搜索树，中序遍历的同时，检查一遍就好</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDiffInBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(node.left);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="literal">null</span>) &#123;</span><br><span class="line">            pre = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans = Math.min(Math.abs(node.val - pre.val), ans);</span><br><span class="line">            pre = node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="938-二叉搜索树的范围和"><a href="#938-二叉搜索树的范围和" class="headerlink" title="938. 二叉搜索树的范围和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/range-sum-of-bst/">938. 二叉搜索树的范围和</a></h3><h3 id="965-单值二叉树"><a href="#965-单值二叉树" class="headerlink" title="965. 单值二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/univalued-binary-tree/">965. 单值二叉树</a></h3><h3 id="993-二叉树的堂兄弟节点"><a href="#993-二叉树的堂兄弟节点" class="headerlink" title="993. 二叉树的堂兄弟节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/cousins-in-binary-tree/">993. 二叉树的堂兄弟节点</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">xDepth</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">yDepth</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">par</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCousins</span><span class="params">(TreeNode root, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.val == x || root.val == y) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.x = x; <span class="built_in">this</span>.y = y;</span><br><span class="line"></span><br><span class="line">        dfs(root, <span class="number">1</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode node, <span class="type">int</span> height, TreeNode parent)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.val == x) &#123;</span><br><span class="line">            xDepth = height;</span><br><span class="line">            <span class="keyword">if</span> (par == <span class="literal">null</span>) &#123;</span><br><span class="line">                par = parent;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (xDepth == yDepth &amp;&amp; par != parent) &#123;</span><br><span class="line">                    ans = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.val == y) &#123;</span><br><span class="line">            yDepth = height;</span><br><span class="line">            <span class="keyword">if</span> (par == <span class="literal">null</span>) &#123;</span><br><span class="line">                par = parent;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (xDepth == yDepth &amp;&amp; par != parent) &#123;</span><br><span class="line">                    ans = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(node.left, height+<span class="number">1</span>, node);</span><br><span class="line">        dfs(node.right, height+<span class="number">1</span>, node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="原地哈希"><a href="#原地哈希" class="headerlink" title="原地哈希"></a>原地哈希</h2><h3 id="442-数组中重复的数据"><a href="#442-数组中重复的数据" class="headerlink" title="442. 数组中重复的数据"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-all-duplicates-in-an-array/">442. 数组中重复的数据</a></h3><p>看数组中数据的范围，1 &lt;&#x3D; nums[i] &lt;&#x3D; n，而且时间复杂度O（n），空间复杂度常量级别，所以肯定要用到原地哈希。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    原地哈希</span></span><br><span class="line"><span class="comment">    然后numx[i]放到nums[i]-1的位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意，需要两遍，第一遍换到</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 这是代表已经放在该放的地方了</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; <span class="number">0</span> || nums[i]-<span class="number">1</span> == i) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[nums[i]-<span class="number">1</span>] == nums[i]) &#123;</span><br><span class="line">                ans.add(nums[i]);</span><br><span class="line">                nums[i] = -<span class="number">1</span> * nums[i];  <span class="comment">// 为了防止重复计算</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[nums[i]-<span class="number">1</span>];</span><br><span class="line">                nums[nums[i]-<span class="number">1</span>] = nums[i];</span><br><span class="line">                nums[i] = temp;</span><br><span class="line">                i--;   <span class="comment">// 注意这里要i--，因为nums[nums[i]-1]放了现在的nums[i]，但是被换过来的这个没有验证</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> Math.abs(nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (nums[x - <span class="number">1</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                nums[x - <span class="number">1</span>] = -nums[x - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans.add(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="优先队列、单调队列、treeset、treemap"><a href="#优先队列、单调队列、treeset、treemap" class="headerlink" title="优先队列、单调队列、treeset、treemap"></a>优先队列、单调队列、treeset、treemap</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/linysuccess/article/details/109038453?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-109038453-blog-121882303.t5_layer_eslanding_sa_randoms&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-109038453-blog-121882303.t5_layer_eslanding_sa_randoms&utm_relevant_index=1">Java中的栈Stack、Deque、ArrayDeque、LinkedList</a></p>
<blockquote>
<p><strong>ArrayDeque用作栈时比Stack快没有疑问，用作队列的时候似乎也会比LinkedList快！</strong></p>
</blockquote>
<p>找到题眼，有任意两个元素之间的绝对差，那肯定是最大值，最小值。</p>
<p>优先队列，跟只用一个变量来维护最大最小值的区别就是：如果删除这个最大的，还能知道下一个最大的，而变量维护的不行了，只能添加得来。</p>
<p><img src="https://s2.loli.net/2022/08/08/RO7mQAiLajoWdf3.png" alt="treesetpriorityqueue"></p>
<h3 id="1675-数组的最小偏移量"><a href="#1675-数组的最小偏移量" class="headerlink" title="1675. 数组的最小偏移量"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimize-deviation-in-array/">1675. 数组的最小偏移量</a></h3><p>此处其实用treeset更快。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumDeviation</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用优先队列，或者使用treeset</span></span><br><span class="line">        <span class="comment">// treeset的话可以拿到最大值和最小值</span></span><br><span class="line">        <span class="comment">// 而优先队列的话只能拿到一个，此处用最大堆，然后维护最小值</span></span><br><span class="line">        <span class="comment">// 先把技术全部*2变成偶数，放入最大堆，然后每次将最大值/2放入，若最大值是奇数，终止</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最大堆</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Integer&gt;((a, b) -&gt; b - a);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE, min = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num: nums) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> num % <span class="number">2</span> == <span class="number">1</span> ? num * <span class="number">2</span> : num;</span><br><span class="line">            queue.offer(temp);</span><br><span class="line">            min = Math.min(temp, min);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            ans = Math.min(ans, max - min);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (max % <span class="number">2</span> == <span class="number">1</span>) &#123; <span class="keyword">break</span>; &#125; <span class="comment">// 若最大值是奇数，终止</span></span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> max / <span class="number">2</span>;</span><br><span class="line">            min = Math.min(temp, min);</span><br><span class="line">            queue.offer(temp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="1438-绝对差不超过限制的最长连续子数组"><a href="#1438-绝对差不超过限制的最长连续子数组" class="headerlink" title="1438. 绝对差不超过限制的最长连续子数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/">1438. 绝对差不超过限制的最长连续子数组</a></h3><p>还是treemap好用啊，单调队列稍微有点麻烦</p>
<p>注意，这个set不能重复，那么可以用map的值来记录个数，这个思想要记住。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestSubarray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> limit)</span> &#123;</span><br><span class="line">        <span class="comment">// 子数组的任意两个元素之间的绝对值差小于等于limitlimit，经典滑动窗口</span></span><br><span class="line">        <span class="comment">// 如何维护最大值和最小值，用treeset吧，但是treeset不能重复啊</span></span><br><span class="line">        <span class="comment">// 那可以用treemap啊，值就放他的个数，如果个数为0，需要remove</span></span><br><span class="line">        <span class="comment">// 用单调队列维护起来稍微麻烦一点，感觉还是treemap好</span></span><br><span class="line"></span><br><span class="line">        TreeMap&lt;Integer, Integer&gt; treeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; nums.length; right++) &#123;</span><br><span class="line">            treeMap.put(nums[right], treeMap.getOrDefault(nums[right], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; treeMap.lastKey() - treeMap.firstKey() &gt; limit) &#123;</span><br><span class="line">                treeMap.put(nums[left], treeMap.get(nums[left]) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (treeMap.get(nums[left]) == <span class="number">0</span>) &#123;</span><br><span class="line">                    treeMap.remove(nums[left]);</span><br><span class="line">                &#125;</span><br><span class="line">                left += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ans = Math.max(ans, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="队列和栈的相互实现"><a href="#队列和栈的相互实现" class="headerlink" title="队列和栈的相互实现"></a><a target="_blank" rel="noopener" href="https://tyzhang.top/article/algo/#12-%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88%E7%9A%84%E7%9B%B8%E4%BA%92%E5%AE%9E%E7%8E%B0">队列和栈的相互实现</a></h3><h4 id="两个栈实现队列"><a href="#两个栈实现队列" class="headerlink" title="两个栈实现队列"></a>两个栈实现队列</h4><blockquote>
<p>如果需要弹出队头元素，则将 stack1 中的元素弹出并 push 到 stack2 中，再将 stack2 的栈顶元素弹出，即弹出来队头的元素。</p>
<p>如果 stack2 中非空，再在队尾添加元素的时候仍然添加到 stack1 中，再从 stack2 中弹出队头元素。</p>
<p>如果 stack2 为空，弹出队头元素才需要将 stack1 中的元素转移到 stack2 中。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> node)</span> &#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stack2.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (stack1.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="两个队列实现栈"><a href="#两个队列实现栈" class="headerlink" title="两个队列实现栈"></a>两个队列实现栈</h4><blockquote>
<p>两个队列实现栈，弹出元素的时候，把队列中的元素放到另一个队列中，删除最后一个元素。</p>
<p>两个队列始终保持只有一个队列是有数据的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    Queue&lt;Integer&gt; queue2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!queue1.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> queue1.offer(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> queue2.offer(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (queue1.isEmpty() &amp;&amp; queue2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;栈为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!queue1.isEmpty() &amp;&amp; queue2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue1.size() != <span class="number">1</span>) &#123;</span><br><span class="line">                queue2.offer(queue1.poll());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> queue1.poll();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue2.size() != <span class="number">1</span>) &#123;</span><br><span class="line">                queue1.offer(queue2.poll());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> queue2.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="641-设计循环双端队列"><a href="#641-设计循环双端队列" class="headerlink" title="641. 设计循环双端队列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/design-circular-deque/">641. 设计循环双端队列</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCircularDeque</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] nums;</span><br><span class="line">    <span class="type">int</span> he, ta, cnt, k;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyCircularDeque</span><span class="params">(<span class="type">int</span> _k)</span> &#123;</span><br><span class="line">        k = _k;</span><br><span class="line">        nums = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">insertFront</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        he = (he + k - <span class="number">1</span>) % k;</span><br><span class="line">        nums[he] = value; cnt++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">insertLast</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        nums[ta++] = value; cnt++;</span><br><span class="line">        ta %= k;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deleteFront</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        he = (he + <span class="number">1</span>) % k; cnt--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deleteLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ta = (ta + k - <span class="number">1</span>) % k; cnt--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getFront</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isEmpty() ? -<span class="number">1</span> : nums[he];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRear</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isEmpty() ? -<span class="number">1</span> : nums[(ta + k - <span class="number">1</span>) % k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">cnt</span> <span class="operator">=</span>= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">cnt</span> <span class="operator">=</span>= k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/discuss/966053">面试官：给你十分钟，写出可以增删查改任意位置插入删除的链表！</a></p>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wmy0217_/article/details/104972191">并查集算法</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/most-stones-removed-with-same-row-or-column/solution/tu-jie-bing-cha-ji-by-yexiso-nbcz/">【详解】并查集</a></p>
<h3 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h3><p>题目描述</p>
<blockquote>
<p>给定一个包含n个点（编号为1~n）的无向图，初始时图中没有边。</p>
<p>现在要进行m个操作，操作共有三种：</p>
<p>“C a b”，在点a和点b之间连一条边，a和b可能相等；<br>“Q1 a b”，询问点a和点b是否在同一个连通块中，a和b可能相等；<br>“Q2 a”，询问点a所在连通块中点的数量；</p>
</blockquote>
<p>输入格式</p>
<blockquote>
<p>第一行输入整数n和m。</p>
<p>接下来m行，每行包含一个操作指令，指令为“C a b”，“Q1 a b”或“Q2 a”中的一种。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> p[N],size[N]; <span class="comment">//p[N]存每个结点的父结点，size[N]存每个集合的元素个数</span></span><br><span class="line"><span class="comment">//只有祖宗结点的size才有意义 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">//返回x的祖宗结点+路径优化 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">if</span>(p[x]!=x) p[x]=<span class="built_in">find</span>(p[x]); <span class="comment">//p[x]!=x说明不是祖宗结点 </span></span><br><span class="line">	<span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		p[i]=i;    <span class="comment">//刚开始每个元素都是各自在一个集合内，此时所有元素的p[x]=x </span></span><br><span class="line">		size[i]=<span class="number">1</span>; <span class="comment">// 刚开始每个集合都只有一个元素 </span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(m--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">char</span> op[<span class="number">5</span>];</span><br><span class="line">		<span class="type">int</span> a,b;</span><br><span class="line">		cin&gt;&gt;op;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;C&#x27;</span>) <span class="comment">//合并 </span></span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b)) <span class="keyword">continue</span>; <span class="comment">//a和b已经在一个集合了</span></span><br><span class="line">			size[<span class="built_in">find</span>(b)] += size[<span class="built_in">find</span>(a)]; <span class="comment">//合并后b(size)=b(size)+a(size)</span></span><br><span class="line">			p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b); </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) <span class="comment">//查询是否在同一集合 </span></span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b)) cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">			<span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="comment">//查询集合内元素个数</span></span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;a;</span><br><span class="line">			cout&lt;&lt;size[<span class="built_in">find</span>(a)]&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="股票推荐"><a href="#股票推荐" class="headerlink" title="股票推荐"></a>股票推荐</h3><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/-_ALl1I9EIKAfR8gTvIovw">ZOOM秋招笔试</a></p>
<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>完成股票推荐系统设计，每个用户可能关注几个公司，比如A,B,C，如果有另一个用户只关注了A，那么就会给他推荐B，C。这时候如果来了一个用户关注C，D，那么后来关注C的用户，都会推荐A，B，关注A的用户都会推荐BCD。在有上面的关系后，求用户查询的时候，会给它推荐的公司的个数。</p>
</blockquote>
<h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>第一行输入q表示操作次数 接下来输入一次操作 共有两种操作 1.注册 格式为 1 name n 表示有一个name的人关注了n个股票 第二行输入n个字符串表示这n个股票 n个字符串不相同 2.查询 格式为 输入2 name 表示查询系统会给此人推荐多少股票 保证至少有一次查询 例</p>
<blockquote>
<p>5<br>1 Alice 2<br>Zoom Apple<br>2 Bob<br>2 Alice<br>1 Bob 2<br>Apple MicroSoft<br>2 Bob</p>
</blockquote>
<p>见，面经章节</p>
<h3 id="1631-最小体力消耗路径"><a href="#1631-最小体力消耗路径" class="headerlink" title="1631. 最小体力消耗路径"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-with-minimum-effort/">1631. 最小体力消耗路径</a></h3><h4 id="并查集-Kruskal"><a href="#并查集-Kruskal" class="headerlink" title="并查集 + Kruskal"></a><strong>并查集 + Kruskal</strong></h4><blockquote>
<p>一条路径耗费的 <strong>体力值</strong> 是路径上相邻格子之间 <strong>高度差绝对值</strong> 的 <strong>最大值</strong> 决定的。</p>
<p>而不是，所有体力值之和决定的</p>
</blockquote>
<p>注意：</p>
<p>1 合并成为联通图什么的，首先是根据题目意思看需要如何建图，比如这一题要用可如斯特，所以需要[a, b, w]，编号1，编号2，然后权重</p>
<p>2 然后为了合并，需要将二维的index改成一维的编号，比如是个矩阵，那么$x * col + y$这个编号就好，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.jcwang.zoom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnionFind1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Solution</span> <span class="variable">solution</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind1</span>().<span class="keyword">new</span> <span class="title class_">Solution</span>();</span><br><span class="line">        System.out.println(solution.minimumEffortPath(<span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">9</span>&#125;&#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         考虑并查集 + Krustal</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 1 并查集，变量（parent代表该编号的父节点编号是谁，所以节点编号需要一维，而且数组的大小一定要能满足题目所有的点）\</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">10009</span>;</span><br><span class="line">        <span class="type">int</span>[] parent = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        <span class="comment">// 2 并查集：查找根节点</span></span><br><span class="line">        <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent[x] != x) &#123;</span><br><span class="line">                <span class="comment">// 让所有查到到的该路径节点的parent直接指向最终的父节点编号，加快下次遍历</span></span><br><span class="line">                parent[x] = find(parent[x]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> parent[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3 并查集：查询是否联通，看两个根节点是否一致</span></span><br><span class="line">      	<span class="comment">// 注意，下面find已经找到根了，parent[find(a)]是等于find(a)的，所以其实简写也没关系的</span></span><br><span class="line">        <span class="type">boolean</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (parent[find(a)] == parent[find(b)]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4 并查集：融合，两个根容易下就行</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">            <span class="comment">// 当然，此处没有优化，没有考虑a和b哪一个深，如果a深，那么最好parent[b] = parent[a]</span></span><br><span class="line">            <span class="comment">// 要实现优化的话，需要多一个变量rank[]记录深度</span></span><br><span class="line">            parent[find(a)] = parent[find(b)];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5 并查集，得到编号，本身一维的就不会需要这个函数了</span></span><br><span class="line">        <span class="type">int</span> col;</span><br><span class="line">        <span class="type">int</span> row;</span><br><span class="line">        <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x * col + y;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumEffortPath</span><span class="params">(<span class="type">int</span>[][] heights)</span> &#123;</span><br><span class="line">            col = heights[<span class="number">0</span>].length;</span><br><span class="line">            row = heights.length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 6 首先初始化并查集</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; row * col; i++) &#123;</span><br><span class="line">                parent[i] = i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 由于需要Krustal，所以使用点-点-权重的建图方式</span></span><br><span class="line">            <span class="comment">// 预处理出所有的边</span></span><br><span class="line">            <span class="comment">// edge 存的是 [a, b, w]：代表从 a 到 b 的体力值为 w</span></span><br><span class="line">            <span class="comment">// 虽然我们可以往四个方向移动，但是只要对于每个点都添加「向右」和「向下」两条边的话，其实就已经覆盖了所有边了</span></span><br><span class="line">            List&lt;<span class="type">int</span>[]&gt; edges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> getIndex(i, j);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 往下</span></span><br><span class="line">                    <span class="keyword">if</span> (i + <span class="number">1</span> &lt; row) &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> getIndex(i+<span class="number">1</span>, j);</span><br><span class="line">                        edges.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;cur, next, Math.abs(heights[i][j] - heights[i+<span class="number">1</span>][j])&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 往右</span></span><br><span class="line">                    <span class="keyword">if</span> (j + <span class="number">1</span> &lt; col) &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> getIndex(i, j+<span class="number">1</span>);</span><br><span class="line">                        edges.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;cur, next, Math.abs(heights[i][j] - heights[i][j+<span class="number">1</span>])&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// krustal算法需要排序</span></span><br><span class="line">            Collections.sort(edges, (a, b) -&gt; (a[<span class="number">2</span>] - b[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> getIndex(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> getIndex(row - <span class="number">1</span>, col - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 从小边开始添加</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> edge[<span class="number">0</span>], y = edge[<span class="number">1</span>], w = edge[<span class="number">2</span>];</span><br><span class="line">                <span class="keyword">if</span> (!query(x, y)) &#123; <span class="comment">// 需要判断，不联通的时候，才添加</span></span><br><span class="line">                    union(x, y);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 若起点和终点都联通了，那么路径已经通了</span></span><br><span class="line">                    <span class="keyword">if</span> (query(start, end)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> w;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="947-移除最多的同行或同列石头"><a href="#947-移除最多的同行或同列石头" class="headerlink" title="947. 移除最多的同行或同列石头"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/most-stones-removed-with-same-row-or-column/">947. 移除最多的同行或同列石头</a></h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wmy0217_/article/details/104972191">并查集算法</a></p>

    </div>
    
    <div class="post__license">
        <p>
            <strong>Author: </strong>Jcwang
        </p>
        <p>
            <strong>
                Permalink: 
            </strong>
            <a href="http://example.com/2022/07/13/AlgorithmClassfication3/">http://example.com/2022/07/13/AlgorithmClassfication3/</a>
        </p>
        
    </div>
 
    <div class="post-footer__meta"><p>updated at 2022-08-16</p></div> 
    <div class="post-entry__tags"></div> 
</article>


    <div class="nav">
        <div class="nav__prev">
            
                <a href="/2022/07/18/javaguide/" class="nav__link">
                    <div>
                        <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M589.088 790.624L310.464 512l278.624-278.624 45.248 45.248L400.96 512l233.376 233.376z" fill="#808080"></path></svg>
                    </div>
                    <div>
                        <div class="nav__label">
                            Previous Post
                        </div>
                        <div class="nav__title">
                            Javaguide
                        </div>
                    </div>
                </a>
            
        </div>
        <div class="nav__next">
            
                <a href="/2022/07/11/%E9%9D%A2%E8%AF%95%E5%AE%A3%E8%AE%B2%E4%BC%9A/" class="nav__link">
                    <div>
                        <div class="nav__label">
                            Next Post
                        </div>
                        <div class="nav__title">
                            面试宣讲会
                        </div>
                    </div>
                    <div>
                        <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M434.944 790.624l-45.248-45.248L623.04 512l-233.376-233.376 45.248-45.248L713.568 512z" fill="#808080"></path></svg>
                    </div>
                </a>
            
        </div>
    </div>





</main>

            <footer class="footer">
    
    


    
     
 

 
    
        
        <p class="footer-copyright">
            Copyright © 2019&nbsp;-&nbsp;2022 <a href="/">穿过海的声音</a>
        </p>
    
    
    <p>Powered by <a href="https://hexo.io" target="_blank">Hexo</a> | Theme - <a href="https://github.com/ChrAlpha/hexo-theme-cards" target="_blank">Cards</a></p>
</footer>

        </div>
         

 

 

 

 



 



 


    
 

 

 

 

 

 




    </body>
</html>
